// Generated by CoffeeScript 1.6.2
(function() {
  var Stream, coffee, coffee_helpers, compile, conf, convert, errx, fs, is_literate, optparse, parse_opts, path, read_file, read_stdin;

  fs = require('fs');

  path = require('path');

  Stream = require('stream');

  coffee = require('coffee-script');

  coffee_helpers = require('coffee-script/lib/coffee-script/helpers');

  convert = require('convert-source-map');

  optparse = require('optparse');

  conf = {
    quiet: false,
    progname: path.basename(process.argv[1]),
    progver: JSON.parse(fs.readFileSync("" + __dirname + "/../package.json")).version,
    maps: true,
    output: process.stdout
  };

  errx = function(exit_code, msg) {
    if (!conf.quiet) {
      console.error("" + conf.progname + " error: " + msg);
    }
    if (exit_code) {
      return process.exit(exit_code);
    }
  };

  parse_opts = function(src) {
    var opt, p;
    opt = [["-h", "--help", "output usage information & exit"], ["-V", "--version", "output the version number & exit"], ["-o", "--output [FILE]", "write result to a FILE instead of stdout"], ["--no-map", "don't include inline source map (why?)"]];
    p = new optparse.OptionParser(opt);
    p.banner = "Usage: " + conf.progname + " [options] [file.coffee]";
    p.on('no-map', function() {
      return conf.maps = false;
    });
    p.on('help', function() {
      console.log(p.toString());
      return process.exit(0);
    });
    p.on('version', function() {
      console.log(conf.progver);
      return process.exit(0);
    });
    p.on('output', function(unused, val) {
      return conf.output = val;
    });
    p.on(function(o) {
      return errx(1, "unknown option " + o);
    });
    return [p.parse(src), p];
  };

  is_literate = function(fname) {
    if ('.litcoffee' === path.extname(fname)) {
      return true;
    }
    return false;
  };

  read_file = function(fname) {
    var e;
    try {
      return fs.readFileSync(fname).toString();
    } catch (_error) {
      e = _error;
      return errx(1, "" + fname + " reading: " + e.message);
    }
  };

  read_stdin = function() {
    return read_file('/dev/stdin');
  };

  compile = function(fname, fcontent) {
    var comment, compiled, e, inColor;
    if (fcontent.match(/^\s*$/)) {
      return '';
    }
    try {
      compiled = coffee.compile(fcontent, {
        sourceMap: conf.maps,
        generatedFile: fname,
        inline: true,
        literate: is_literate(fname)
      });
    } catch (_error) {
      e = _error;
      inColor = process.stderr.isTTY ? true : false;
      console.error(coffee_helpers.prettyErrorMessage(e, fname, fcontent, inColor));
      process.exit(1);
    }
    if (conf.maps) {
      comment = convert.fromJSON(compiled.v3SourceMap).setProperty('sources', [fname]).toComment();
      return "" + compiled.js + "\n" + comment;
    } else {
      return compiled.toString();
    }
  };

  exports.main = function() {
    var args, js, p, _ref;
    _ref = parse_opts(process.argv), args = _ref[0], p = _ref[1];
    args = args.slice(2);
    if (args.length) {
      js = compile(args[0], read_file(args[0]));
    } else {
      js = compile('[stdin]', read_stdin());
    }
    if (!(conf.output instanceof Stream)) {
      conf.output = fs.createWriteStream(conf.output);
    }
    conf.output.on('error', function(err) {
      return errx(1, "output stream: " + err.message);
    });
    conf.output.write(js);
    if (conf.output.path) {
      return conf.output.end();
    }
  };

}).call(this);
