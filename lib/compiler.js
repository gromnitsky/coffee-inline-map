// Generated by CoffeeScript 1.9.1
(function() {
  var Stream, coffee, coffee_helpers, compile, conf, convert, errx, fs, optparse, parse_opts, path, read_file, read_stdin;

  fs = require('fs');

  path = require('path');

  Stream = require('stream');

  coffee = require('coffee-script');

  coffee_helpers = require('coffee-script/lib/coffee-script/helpers');

  convert = require('convert-source-map');

  optparse = require('optparse');

  conf = {
    quiet: false,
    progname: path.basename(process.argv[1]),
    progver: JSON.parse(fs.readFileSync(__dirname + "/../package.json")).version,
    maps: true,
    output: process.stdout,
    stdin_literate: false,
    bare: false,
    header: true
  };

  errx = function(exit_code, msg) {
    if (!conf.quiet) {
      console.error(conf.progname + " error: " + msg);
    }
    if (exit_code) {
      return process.exit(exit_code);
    }
  };

  parse_opts = function(src) {
    var opt, p;
    opt = [["-h", "--help", "output usage information & exit"], ["-V", "--version", "output the version number & exit"], ["-o", "--output [FILE]", "write result to a FILE instead of stdout"], ["-l", "--literate", "treat stdin as literate style coffee-script"], ["-b", "--bare", "compile without a top-level function wrapper"], ["--no-map", "don't include inline source map (why?)"]];
    p = new optparse.OptionParser(opt);
    p.banner = "Usage: " + conf.progname + " [options] [file.coffee]";
    p.on('no-map', function() {
      return conf.maps = false;
    });
    p.on('bare', function() {
      return conf.bare = true;
    });
    p.on('help', function() {
      console.log(p.toString());
      return process.exit(0);
    });
    p.on('version', function() {
      console.log(conf.progver);
      return process.exit(0);
    });
    p.on('output', function(unused, val) {
      return conf.output = val;
    });
    p.on('literate', function() {
      return conf.stdin_literate = true;
    });
    p.on(function(o) {
      return errx(1, "unknown option " + o);
    });
    return [p.parse(src), p];
  };

  read_file = function(fname) {
    var e;
    try {
      return fs.readFileSync(fname).toString();
    } catch (_error) {
      e = _error;
      return errx(1, fname + " reading: " + e.message);
    }
  };

  read_stdin = function() {
    return read_file('/dev/stdin');
  };

  compile = function(fname, fcontent, opt) {
    var comment, compiled, e, key, options, val;
    if (opt == null) {
      opt = {};
    }
    if (fcontent.match(/^\s*$/)) {
      return '';
    }
    options = {
      sourceMap: conf.maps,
      generatedFile: fname,
      filename: fname,
      bare: conf.bare,
      header: conf.header,
      inline: true,
      literate: coffee_helpers.isLiterate(fname)
    };
    for (key in opt) {
      val = opt[key];
      options[key] = val;
    }
    try {
      compiled = coffee.compile(fcontent, options);
    } catch (_error) {
      e = _error;
      console.error(coffee_helpers.updateSyntaxError(e.toString(), fcontent, fname));
      process.exit(1);
    }
    if (conf.maps) {
      comment = convert.fromJSON(compiled.v3SourceMap).setProperty('sources', [fname]).toComment();
      return compiled.js + "\n" + comment;
    } else {
      return compiled.toString();
    }
  };

  exports.main = function() {
    var args, js, p, ref;
    ref = parse_opts(process.argv), args = ref[0], p = ref[1];
    args = args.slice(2);
    if (args.length) {
      js = compile(args[0], read_file(args[0]));
    } else {
      js = compile('[stdin]', read_stdin(), {
        literate: conf.stdin_literate
      });
    }
    if (!(conf.output instanceof Stream)) {
      conf.output = fs.createWriteStream(conf.output);
    }
    conf.output.on('error', function(err) {
      return errx(1, "output stream: " + err.message);
    });
    conf.output.write(js);
    if (conf.output.path) {
      return conf.output.end();
    }
  };

}).call(this);
